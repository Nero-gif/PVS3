[
  {
    "id": "lekce-0",
    "title": "Lekce 0 — Jak spouštět Java projekty",
    "subtitle": "Základní spuštění a kompilace",
    "keywords": "javac java spouštět compile run",
    "content": "<p>Cílem lekce je ukázat, jak zkompilovat a spustit jednoduchý Java program z příkazové řádky a jak pracovat lokálně s repozitářem.</p>\n\n<h3>Rychlý přehled příkazů</h3>\n<ul>\n  <li><code class=\"inline\">javac src/Main.java</code> — zkompiluje soubor Main.java (vytvoří .class soubor)</li>\n  <li><code class=\"inline\">java -cp src Main</code> — spustí třídu Main (třída musí obsahovat public static void main)</li>\n  <li><code class=\"inline\">git clone &lt;url&gt;</code>, <code class=\"inline\">git pull</code> — práce s git/repozitářem</li>\n</ul>\n\n<h3>Příklad: jednoduchý program</h3>\n<pre class=\"code\">public class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Ahoj světe\");\n    }\n}</pre>\n\n<div class=\"exercise\"><strong>Cvičení:</strong> Naklonuj repozitář, otevři src/Main.java, zkompiluj a spusť výše uvedený program. Uprav ho tak, aby vytiskl tvé jméno a věk.</div>\n\n<p><strong>Tip:</strong> Pokud používáš IDE (IntelliJ, Eclipse), spuštění a kompilace jsou integrovány — ale je dobré znát příkazy z příkazové řádky pro nasazení nebo ladění mimo IDE.</p>"
  },
  {
    "id": "lekce-1",
    "title": "Lekce 1 — Základy Javy",
    "subtitle": "Proměnné, datové typy, operátory, řízení toku programu",
    "keywords": "proměnné typy if for while switch",
    "content": "<p>Tato lekce pokrývá základní datové typy a příkazy v Javě, jak deklarovat proměnné a použít základní řídicí konstrukce.</p>\n\n<h3>Krátká teorie</h3>\n<ul>\n  <li>Primární typy: <code>int</code>, <code>long</code>, <code>double</code>, <code>boolean</code>, <code>char</code>.</li>\n  <li>Řetězce: <code>String</code> — objekt, nepoužívej operátor == pro porovnávání obsahu (použij <code>equals</code>).</li>\n  <li>Řídicí struktury: <code>if/else</code>, <code>switch</code>, cykly <code>for</code>, <code>while</code>, \"enhanced for\" (foreach).</li>\n</ul>\n\n<h3>Příklad: faktoriál (iterativní, kontrola vstupu)</h3>\n<pre class=\"code\">import java.util.Scanner;\n\npublic class Factorial {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        System.out.print(\"Zadej n (0..20): \");\n        if (!sc.hasNextLong()) {\n            System.out.println(\"Chybný vstup.\");\n            return;\n        }\n        long n = sc.nextLong();\n        if (n < 0 || n > 20) {\n            System.out.println(\"Neplatné n (0..20).);\n            return;\n        }\n        long r = 1;\n        for (int i = 2; i <= n; i++) r *= i;\n        System.out.println(n + \"! = \" + r);\n        sc.close();\n    }\n}</pre>\n\n<div class=\"exercise\"><strong>Cvičení:</strong> Napiš program, který načte seznam celých čísel (nejdřív n, pak n čísel) a vypíše jejich průměr (double).</div>\n\n<p><strong>Běžné chyby:</strong> dělení <code>int/int</code> vrátí celočíselný výsledek; pro reálný výsledek přetypuj na <code>double</code>.</p>"
  },
  {
    "id": "lekce-2",
    "title": "Lekce 2 — Pole a kolekce",
    "subtitle": "Arrays, ArrayList a základní operace",
    "keywords": "pole array arraylist kolekce",
    "content": "<p>Tato lekce vysvětluje rozdíl mezi statickými poli a dynamickými kolekcemi v Javě (hlavně <code>ArrayList</code>), a jak s nimi pracovat.</p>\n\n<h3>Teorie</h3>\n<ul>\n  <li><code>int[] arr = new int[10];</code> — pole s pevnou velikostí.</li>\n  <li><code>List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</code> — dynamická kolekce, lze přidávat a odebírat.</li>\n  <li>Iterace: klasický <code>for (int i=0; i&lt;arr.length; i++)</code> nebo \"enhanced for\": <code>for (int x : arr)</code>.</li>\n</ul>\n\n<h3>Příklad: maximum v poli</h3>\n<pre class=\"code\">public static int max(int[] a) {\n    if (a == null || a.length == 0) throw new IllegalArgumentException(\"Prázdné pole\");\n    int m = a[0];\n    for (int i = 1; i &lt; a.length; i++) if (a[i] &gt; m) m = a[i];\n    return m;\n}\n\n// použití:\n// int[] data = {3, 7, 2}; // System.out.println(max(data)); // 7</pre>\n\n<div class=\"exercise\"><strong>Cvičení:</strong> Přepiš metodu <code>max</code>, aby vracela index maxima místo hodnoty. Přidej testy.</div>\n\n<p><strong>Tip:</strong> Pro třídění kolekce použij <code>Collections.sort(list)</code> nebo <code>Arrays.sort(arr)</code> pro pole.</p>"
  },
  {
    "id": "lekce-3",
    "title": "Lekce 3 — Metody a rekurze",
    "subtitle": "Definice metod, přetížení, rekurze, scope proměnných",
    "keywords": "metody funkce rekurze",
    "content": "<p>Vysvětlíme, jak definovat metody (statické i instanční), parametry, návratové hodnoty, přetížení metod a základy rekurze.</p>\n\n<h3>Teorie</h3>\n<ul>\n  <li>Signature metody: <code>public static int sum(int a, int b)</code></li>\n  <li>Lokální a instanční proměnné: rozsah (scope) proměnné je omezen blokem, kde je definována.</li>\n  <li>Rekurze: funkce volá sama sebe; dávej pozor na podmínku ukončení a spotřebu zásobníku (stack).</li>\n</ul>\n\n<h3>Příklad: Fibonacci rekurzivně a iterativně</h3>\n<pre class=\"code\">// rekurzivní (exponenciální čas)\npublic static int fibR(int n) {\n    if (n &lt;= 1) return n;\n    return fibR(n-1) + fibR(n-2);\n}\n\n// iterativní (lineární čas)\npublic static int fibI(int n) {\n    if (n &lt;= 1) return n;\n    int a = 0, b = 1;\n    for (int i = 2; i &lt;= n; i++) {\n        int t = a + b;\n        a = b;\n        b = t;\n    }\n    return b;\n}</pre>\n\n<div class=\"exercise\"><strong>Cvičení:</strong> Implementuj memoizovanou verzi Fibonacciho (použij pole nebo mapu) a porovnej rychlost s rekurzivní verzí pro n=35.</div>\n\n<p><strong>Tip:</strong> Rekurzivní řešení je často čisté a krátké, ale nezapomínej myslet na efektivitu a hloubku volání.</p>"
  },
  {
    "id": "lekce-4",
    "title": "Lekce 4 — OOP I: Třídy a objekty",
    "subtitle": "Vytváření tříd, konstruktory, zapouzdření a toString",
    "keywords": "class object constructor this getter setter toString",
    "content": "<p>Tato lekce se věnuje základům objektově orientovaného programování: definice třídy, atributy, metody, konstruktory a zapouzdření.</p>\n\n<h3>Teorie</h3>\n<ul>\n  <li>Encapsulation: pole třídy deklarujeme jako <code>private</code> a poskytujeme veřejné gettery/settery.</li>\n  <li>this: odkaz na aktuální instanci (používá se v konstruktorech a metodách).</li>\n  <li>toString: přepiš <code>toString()</code> pro čitelné výstupy.</li>\n</ul>\n\n<h3>Příklad: třída Student</h3>\n<pre class=\"code\">public class Student {\n    private String name;\n    private int points;\n\n    public Student(String name, int points) {\n        this.name = name;\n        this.points = points;\n    }\n\n    public String getName() { return name; }\n    public int getPoints() { return points; }\n    public void setPoints(int points) { this.points = points; }\n\n    @Override\n    public String toString() { return name + \" (\" + points + \")\"; }\n}\n\n// použití:\n// Student s = new Student(\"Anna\", 85); System.out.println(s);</pre>\n\n<div class=\"exercise\"><strong>Cvičení:</strong> Vytvoř třídu <code>Classroom</code>, která obsahuje seznam studentů a metodu pro výpočet průměru bodů a nalezení nejlepšího studenta.</div>\n\n<p><strong>Tip:</strong> Preferuj kompozici (vlastnosti třídy jako jiné třídy) před zbytečnou dědičností.</p>"
  },
  {
    "id": "lekce-5",
    "title": "Lekce 5 — OOP II: Dědičnost a rozhraní",
    "subtitle": "extends, super, overriding, interface a polymorfismus",
    "keywords": "dědičnost extends interface polymorfismus overriding super abstract",
    "content": "<p>V této lekci se naučíš používat dědičnost (<code>extends</code>), přepisování metod (overriding), abstraktní třídy a rozhraní (<code>interface</code>), a princip polymorfismu.</p>\n\n<h3>Teorie</h3>\n<ul>\n  <li>Dědičnost: podtřída dědí chování nadtřídy a může ho rozšířit nebo přepsat.</li>\n  <li>super: volání konstruktoru nebo metody rodiče <code>super(...)</code>, <code>super.method()</code>.</li>\n  <li>Polymorfismus: proměnná typu rodiče může držet instanci potomka a volat přepsané metody dynamicky.</li>\n</ul>\n\n<h3>Příklad: rozhraní Animal + implementace</h3>\n<pre class=\"code\">public interface Animal {\n    void speak();\n}\n\npublic class Dog implements Animal {\n    @Override\n    public void speak() { System.out.println(\"Haf\"); }\n}\n\npublic class Cat implements Animal {\n    @Override\n    public void speak() { System.out.println(\"Mňau\"); }\n}\n\n// použití polymorfismu:\n// List&lt;Animal&gt; animals = Arrays.asList(new Dog(), new Cat()); for (Animal a : animals) a.speak();</pre>\n\n<div class=\"exercise\"><strong>Cvičení:</strong> Vytvoř abstraktní třídu <code>Shape</code> s abstraktní metodou <code>area()</code> a implementuj <code>Circle</code> a <code>Rectangle</code>.</div>\n\n<p><strong>Tip:</strong> Používej rozhraní, když chceš definovat kontrakt chování bez sdílení implementace; abstraktní třídy když chceš znovu použít společnou implementaci.</p>"
  },
  {
    "id": "lekce-6",
    "title": "Lekce 6 — OOP III: Design a návrhové vzory",
    "subtitle": "Kompozice vs. dědičnost, Singleton, Factory pattern",
    "keywords": "design pattern singleton factory composition",
    "content": "<p>Seznámíme se se základními návrhovými vzory a zásadami návrhu: kdy použít kompozici místo dědičnosti a ukážeme dva jednoduché vzory (Singleton, Factory).</p>\n\n<h3>Singleton (thread-safe)</h3>\n<pre class=\"code\">public class Singleton {\n    private static volatile Singleton INSTANCE;\n    private Singleton() {}\n    public static Singleton getInstance() {\n        if (INSTANCE == null) {\n            synchronized (Singleton.class) {\n                if (INSTANCE == null) INSTANCE = new Singleton();\n            }\n        }\n        return INSTANCE;\n    }\n}</pre>\n\n<h3>Factory (jednoduchá továrna)</h3>\n<pre class=\"code\">public class AnimalFactory {\n    public static Animal create(String type) {\n        switch (type.toLowerCase()) {\n            case \"dog\": return new Dog();\n            case \"cat\": return new Cat();\n            default: throw new IllegalArgumentException(\"Unknown type\");\n        }\n    }\n}</pre>\n\n<div class=\"exercise\"><strong>Cvičení:</strong> Implementuj továrnu, která podle řetězce vytvoří daný <code>Shape</code> (kruhový, obdélník) a vypočítá jeho plochu.</div>\n\n<p><strong>Tip:</strong> Preferuj kompozici (obsahovat jiné objekty) kdykoli je to možné — je flexibilnější než hluboká dědičnost.</p>"
  },
  {
    "id": "lekce-7",
    "title": "Lekce 7 — Generika",
    "subtitle": "Parametrizované třídy a metody, wildcardy, typová bezpečnost",
    "keywords": "generics &lt;T&gt; wildcard extends super type-safety",
    "content": "<p>Generika poskytují bezpečnost typů za běhu i při kompilaci a umožňují psát znovupoužitelný kód bez castů.</p>\n\n<h3>Základy</h3>\n<ul>\n  <li><code>List&lt;String&gt; list = new ArrayList&lt;&gt;();</code> — bez generik by byly potřeba explicitní přetypování.</li>\n  <li>Wildcardy: <code>? extends T</code> (covariantní, čteme hodnoty), <code>? super T</code> (kontravariantní, zapisujeme hodnoty bezpečně).</li>\n</ul>\n\n<h3>Příklad: Pair a sumList</h3>\n<pre class=\"code\">public class Pair&lt;T, U&gt; {\n    public final T a;\n    public final U b;\n    public Pair(T a, U b) { this.a = a; this.b = b; }\n}\n\npublic static double sumList(List&lt;? extends Number&gt; nums) {\n    double s = 0;\n    for (Number n : nums) s += n.doubleValue();\n    return s;\n}</pre>\n\n<div class=\"exercise\"><strong>Cvičení:</strong> Napiš generickou třídu <code>Triple&lt;A,B,C&gt;</code> a metodu, která porovná dvě <code>Pair&lt;? extends Comparable&lt;?&gt;, ?&gt;</code> podle první hodnoty.</div>\n\n<p><strong>Tip:</strong> Generika jsou kompilátorová kontrola — pomáhají odhalit chyby dříve. Nepoužívej <code>raw types</code> (např. List bez generiky).</p>"
  },
  {
    "id": "lekce-8",
    "title": "Lekce 8 — Výjimky",
    "subtitle": "Ošetření chyb: try/catch/finally, checked vs unchecked, vlastní výjimky",
    "keywords": "exception try catch finally custom checked unchecked",
    "content": "<p>Tato lekce vysvětlí, jak v Javě zachytávat a zpracovávat chyby pomocí výjimek, rozdíl mezi checked a unchecked výjimkami a jak vytvořit vlastní výjimku.</p>\n\n<h3>Základní konstrukce</h3>\n<ul>\n  <li><code>try { ... } catch (ExceptionType e) { ... } finally { ... }</code></li>\n  <li>Checked výjimky (musí být deklarovány v signatuře metody nebo zachyceny) vs unchecked (RuntimeException a jeho potomci).</li>\n</ul>\n\n<h3>Příklad: vlastní výjimka a použití</h3>\n<pre class=\"code\">public class InvalidDataException extends Exception {\n    public InvalidDataException(String msg) { super(msg); }\n}\n\npublic void validate(int x) throws InvalidDataException {\n    if (x &lt; 0) throw new InvalidDataException(\"Hodnota nesmí být záporná\");\n}\n\n// volání\ntry {\n    validate(-1);\n} catch (InvalidDataException e) {\n    System.err.println(\"Chyba: \" + e.getMessage());\n}</pre>\n\n<div class=\"exercise\"><strong>Cvičení:</strong> Napiš metodu pro čtení čísel ze souboru, která vrátí seznam; ošetři I/O chyby a parsovací chyby s vhodnými zprávami pro uživatele.</div>\n\n<p><strong>Tip:</strong> Nezachytávej obecnou <code>Exception</code>, pokud víš, co přesně očekáváš — buď konkrétní v catch bloku.</p>"
  },
  {
    "id": "lekce-9",
    "title": "Lekce 9 — Reference a paměť",
    "subtitle": "Jak fungují reference v Javě, rozdíl mezi primitivy a referencemi, základy GC",
    "keywords": "reference gc memory strong weak",
    "content": "<p>Vysvětlíme, jak Java pracuje s referencemi na objekty, rozdíl mezi primitivními typy a referencemi, a základ Garbage Collectoru (GC).</p>\n\n<h3>Krátká teorie</h3>\n<ul>\n  <li>Přiřazení objektu nezkopíruje jeho data, ale pouze referenci (ukazatel) na data v heapu.</li>\n  <li>Garbage collector uvolňuje objekty, na které neukazuje žádná živá reference.</li>\n  <li>Existují speciální typy referencí: <code>WeakReference</code>, <code>SoftReference</code> atd. (pokročilejší téma).</li>\n</ul>\n\n<h3>Příklad aliasování</h3>\n<pre class=\"code\">class Box { int value; }\n\nBox a = new Box();\na.value = 5;\nBox b = a; // b a a ukazují na stejný objekt\nb.value = 10;\nSystem.out.println(a.value); // vytiskne 10</pre>\n\n<div class=\"exercise\"><strong>Cvičení:</strong> Napiš metodu, která dostane <code>List&lt;Integer&gt;</code> a v metodě ho upraví (např. vynásobí každou položku 2). Ověř, že úprava se projeví i v původním seznamu.</div>\n\n<p><strong>Tip:</strong> Pochopení referencí je klíčové při práci s mutable objekty a multi-threadingem.</p>"
  },
  {
    "id": "lekce-10",
    "title": "Lekce 10 — Příprava na zkoušku a cvičné úlohy (exams/)",
    "subtitle": "Strategie řešení úloh, příklady, cvičný test",
    "keywords": "zkouška exams příprava úlohy test",
    "content": "<p>Tato lekce shrnuje osvědčený postup při řešení úloh v testu nebo při zkoušce a obsahuje cvičné úlohy.</p>\n\n<h3>Strategie řešení</h3>\n<ol>\n  <li>Přečti zadání úplně. Urči vstupní a výstupní podmínky, okrajové případy.</li>\n  <li>Návrh algoritmu (slovy) – náčrt postupu a odhad složitosti.</li>\n  <li>Napsání kódu s jednoduchými testy (rukou nebo malý main).</li>\n  <li>Otestuj na okrajových vstupních hodnotách a porovnej očekávaný výsledek.</li>\n</ol>\n\n<h3>Cvičný test (návod)</h3>\n<p>Vyber 5 úloh z adresáře <code>src/exams/</code> a dej si časový limit 90 minut. Po ukončení si rozděl čas na kontrolu řešení a testování na dalších vstupech.</p>\n\n<div class=\"exercise\"><strong>Cvičení:</strong> Zkus následující úlohy:\n  <ol>\n    <li>Napiš funkci, která vrátí počet výskytů určité hodnoty v poli.</li>\n    <li>Napiš funkci, která vrátí nejdelší společný prefix (string) ze seznamu řetězců.</li>\n    <li>Implementuj jednoduché třídění (insertion sort) a otestuj ho.</li>\n  </ol>\n</div>\n\n<p><strong>Tip:</strong> Před zkouškou si projdi hlavní třídy z repozitáře (src/) a pochop, co dělají — to často odpovídá zadáním na zkoušce.</p>"
  },
  {
    "id": "Main",
    "title": "Main.java (zdroj z repozitáře)",
    "subtitle": "Auto-generated from src/Main.java",
    "keywords": "main example repo",
    "content": "<p>Tato lekce obsahuje přesný obsah souboru <code>src/Main.java</code> z repozitáře — ukázka jednoduchého programu se smyčkou a větvením.</p>\n\n<pre class=\"code\">//TIP To &lt;b&gt;Run&lt;/b&gt; code, press &lt;shortcut actionId=&quot;Run&quot;/&gt; or\n// click the &lt;icon src=&quot;AllIcons.Actions.Execute&quot;/&gt; icon in the gutter.\npublic class Main {\n    public static void main(String[] args) {\n        for (int i = 1; i &lt;= 10; i++) {\n           if (i % 2 == 0){\n               System.out.println(i);\n           }else {\n               System.err.println(i);\n           }\n        }\n    }\n}</pre>\n\n<p><strong>Vysvětlení:</strong> Smyčka <code>for</code> prochází čísla 1..10. Pokud je číslo sudé (<code>i % 2 == 0</code>), vytiskne ho na standardní výstup (<code>System.out</code>), jinak na chybový výstup (<code>System.err</code>).</p>\n\n<div class=\"exercise\"><strong>Cvičení:</strong> Uprav program tak, aby místo 1..10 tiskl čísla 1..N, kde N se zadá jako první argument programu (<code>args[0]</code>). Ošetři chybné vstupy (není-li argument nebo není-li validní číslo).</div>"
  }
]